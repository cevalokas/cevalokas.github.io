---
layout: post
title: 设计模式-工厂模式
date: 2021-07-01
tags: 设计模式
---

# 简单工厂模式

**不直接向客户端暴露对象创建的细节，而是通过一个工厂类来负责创建产品类的实例。角色：

- 工厂角色；
- 抽象产品角色；
- 具体产品角色。
  **优点：
- 隐藏了对象创建的细节；
- 客户端不需要修改代码
  **缺点：
- 违反了单一职责原则；
- 添加新产品需要修改工厂类代码，违反开闭原则；

# 工厂方法模式

**简单工厂模式只创建一个工厂类，当有新的产品时，需要修改工厂类代码。而 工厂方法模式的'每个具体产品' 对应 '一个具体的工厂类'，不需要修改工厂类代码，并且同时也能满足隐藏对象创建的细节。
角色:

- 抽象工厂角色;
- 具体工厂角色;
- 抽象产品角色;
- 具体产品角色
  **优点：
- 隐藏对象创建的细节；
- 每个具体产品对应一个具体工厂类，不违反开闭；
  **缺点：
- 每增加一个产品类就要增加一个工厂；

# 抽象工厂模式

**定义一个'工厂类的接口' 让 '工厂子类'来创建一系列相关或者相互依赖的对象。
相比工厂方法模式，抽象工厂模式中的每一个具体工厂都生产一套产品。
也就是为了缩减工厂实现子类的数量，不给每一个产品分配一个工厂类，且将产品进行分组，每组中的不同产品由同一个工厂类的不同方法来创建。**
**角色有：

- 抽象工厂角色；
- 具体工厂角色；
- 抽象产品角色；
- 具体产品角色；
  **优点是：
- 将客户端和类的具体实现相分离；
- 每个工厂创建了一个完整的产品系列，使得易于交换产品系列；
- 有利于产品的一致性，即产品之间的约束关系；
  **缺点是：
- 难以支持新种类抽象产品

```python
class foodFactory():

    """

    抽象工厂foodFactory为抽象的工厂类，而burgerFactory，snackFactory，beverageFactory为具体的工厂类。

    """

    type=""

    def createFood(self,foodClass):

        print(self.type," factory produce a instance.")

        foodIns=foodClass()

        return foodIns

class burgerFactory(foodFactory):

    def __init__(self):

        self.type="BURGER"

class snackFactory(foodFactory):

    def __init__(self):

        self.type="SNACK"

class beverageFactory(foodFactory):

    def __init__(self):

        self.type="BEVERAGE"
```

- 简单工厂：唯一工厂类，一个产品抽象类，工厂类的创建方法依据入参判断并创建具体产品对象。
- 工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。
- 抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。

在下述情况下可以考虑使用工厂模式：

1. 在编码时不能预见需要创建哪种类的实例。
2. 系统不应依赖于产品类实例如何被创建、组合和表达的细节。
