---
layout: post
title: 常见搜索
date: 2022-6-30
tags: 数据结构与算法
---

### 1. **线性查找（Linear Search）**

**算法步骤**：

1. 从数组的第一个元素开始，逐个比较目标值和当前元素的值。
2. 如果找到与目标值相等的元素，则返回该元素的索引。
3. 如果遍历了所有元素仍未找到，则返回-1表示未找到。

**性能分析**：

- **时间复杂度**：
  - 最佳情况：目标值在数组的第一个元素，时间复杂度为 $O(1)$。
  - 平均情况：目标值可能在任意位置，时间复杂度为 $O(n)$。
  - 最坏情况：目标值在数组的最后一个元素或不存在，时间复杂度为 $O(n)$。

- **空间复杂度**：$O(1)$，线性查找只需要常量级的额外空间。

### 2. **二分查找（Binary Search）**

**算法步骤**：

1. 二分查找要求数组必须是有序的。
2. 初始化两个指针，分别指向数组的起始位置和结束位置。
3. 计算中间位置的索引，并将中间元素与目标值进行比较。
4. 如果中间元素等于目标值，返回该元素的索引。
5. 如果中间元素大于目标值，将结束指针移至中间元素左侧。
6. 如果中间元素小于目标值，将起始指针移至中间元素右侧。
7. 重复上述步骤，直到找到目标值或指针重合（未找到时返回-1）。

**性能分析**：

- **时间复杂度**：
  - 最佳情况：目标值恰好在中间，时间复杂度为 $O(1)$。
  - 平均情况和最坏情况：时间复杂度为 $O(\log n)$，因为每次查找都会将搜索范围缩小一半。

- **空间复杂度**：$O(1)$，二分查找只需要常量级的额外空间（如果使用递归，空间复杂度为 $O(\log n)$）。

### 3. **跳表查找（Skip List Search）**

**算法步骤**：

1. 构造一个跳表，将链表的每个节点按一定规则连接到不同层次的索引节点中。上层节点的数量是下层节点的1/2。
2. 从跳表的最高层开始，逐层向下查找，找到第一个大于或等于目标值的节点。
3. 如果找到与目标值相等的节点，返回节点的位置。
4. 如果在最低层也未找到目标值，则返回-1。

**性能分析**：

- **时间复杂度**：
  - 最佳情况：目标值在最高层找到，时间复杂度为 $O(1)$。
  - 平均情况和最坏情况：时间复杂度为 $O(\log n)$，因为跳表可以将线性搜索的时间复杂度降低到对数级别。

- **空间复杂度**：$O(n)$，因为需要额外的空间来存储跳表的索引层。

### 4. **散列表查找（Hash Table Search）**

**算法步骤**：

1. 通过哈希函数将目标值映射到哈希表中的一个索引位置。
2. 检查哈希表中该索引位置的桶，如果桶为空，则返回-1表示未找到。
3. 如果桶不为空，逐个检查桶中的元素，寻找与目标值相等的元素。
4. 如果找到目标值，返回该元素的位置；否则，返回-1。

**性能分析**：

- **时间复杂度**：
  - 平均情况：如果哈希函数设计良好，散列表查找的时间复杂度为 $O(1)$。
  - 最坏情况：如果发生大量碰撞（所有元素都映射到同一个桶），时间复杂度退化为 $O(n)$。

- **空间复杂度**：$O(n)$，因为散列表需要额外的存储空间来存储哈希表。

### 5. **插值查找（Interpolation Search）**

**算法步骤**：

1. 插值查找是对二分查找的改进，它基于目标值的位置在数组中的大致位置进行查找，适用于均匀分布的有序数组。
2. 计算目标值可能的位置索引：
   $$ pos = low + \frac{(high - low)}{(arr[high] - arr[low])} \times (target - arr[low]) $$
3. 将目标值与计算出的索引位置的元素进行比较：
   - 如果相等，返回索引位置。
   - 如果目标值小于该元素，则缩小搜索范围到左侧部分。
   - 如果目标值大于该元素，则缩小搜索范围到右侧部分。
4. 重复上述步骤，直到找到目标值或范围缩小为0。

**性能分析**：

- **时间复杂度**：
  - 最佳情况：目标值恰好在计算出的索引位置，时间复杂度为 $O(1)$。
  - 平均情况：时间复杂度为 $O(\log \log n)$，当数据均匀分布时，插值查找比二分查找更快。
  - 最坏情况：时间复杂度为 $O(n)$，当数据分布不均匀时，插值查找可能退化为线性查找。

- **空间复杂度**：$O(1)$，插值查找只需要常量级的额外空间。

### 6. **指数查找（Exponential Search）**

**算法步骤**：

1. 指数查找首先检查目标值是否在数组的前几个元素中，然后逐步增加搜索范围。
2. 先检查数组的第一个元素。如果目标值小于该元素，直接返回-1。
3. 如果目标值大于该元素，从第一个元素开始，指数地增加步长（如2倍、4倍等），直到找到一个大于或等于目标值的范围。
4. 在确定的范围内，使用二分查找精确定位目标值。

**性能分析**：

- **时间复杂度**：
  - 最佳情况：目标值在数组的前几个元素中，时间复杂度为 $O(1)$。
  - 平均情况和最坏情况：时间复杂度为 $O(\log n)$，因为指数查找通过指数增加搜索范围，最终使用二分查找来确定目标值的位置。

- **空间复杂度**：$O(1)$，指数查找只需要常量级的额外空间。

这些查找算法在不同的应用场景中具有不同的优劣。线性查找适用于无序的小规模数据集，而二分查找在有序数组中表现良好。跳表和散列表查找适用于大规模数据集的快速查找，而插值查找和指数查找则在特定的有序数组中能够提供更快的查找速度。