---
layout: post
title: 嵌入式笔记
date: 2023-6-30
tags: 计算机理论
---
## 学习笔记

### 一.基本的GPIO操作

Input/Output）接口是一颗微控制器必须具备的最基本外设功能。通常在ARM 里，所I/O 都是通用的，称为GPIO（General Purpose Input/Output）。简单来说就是STM32可控制的引脚，STM32芯片的GPIO引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。GPIO模块支持多个可编程输入/输出管脚（具体取决于与GPIO 复用的外设的使用情况），STM32芯片的GPIO被分成很多组，每组有16个引脚，如型号为STM32F103ZT型号的芯片有GPIOA、GPIOB、GPIOC至GPIOG共7组GPIO，其中GPIO接口共有112个，所有的GPIO引脚都有基本的输入输出功能。

GPIO引脚线路经过两个保护二极管后，向上流向“输入模式”结构，向下流向“输出模式”结构。先看输出模式部分，线路经过一个由P-MOS和N-MOS管组成的单元电路。这个结构使GPIO具有了“推挽输出”和“开漏输出”两种模式。

前面提到的双MOS管结构电路的输入信号，是由GPIO"输出数据寄存器GPIOx\_ODR"提供的，因此我们通过修改输出数据寄存器的值就可以修改GPIO引脚的输出电平。

初始化函数：

> ***GPIO\_ReadInputDataBit（）/ GPIO\_ReadInputData（） \*\*获得在输入模式下配置的引脚电平。***
>
> ***两个读取输出电平函数：***
>
> ***GPIO\_ReadOnputDataBit（）/ GPIO\_ReadOnputData（） 获得在输出模式下配置的引脚电平。***
>
> ***四个设置输出电平函数：***
>
> ***GPIO\_SetBits（）/ GPIO\_ResetBits（） 设置/复位在输出模式下使用的引脚电平。***
>
> ***GPIO\_Write（）/ GPIO\_WriteBit（） 将数据写入指定的GPIO数据端口。***
>
> ***复用函数：***
>
> ***GPIO\_PinAFConfig() 为单个引脚提供复用的函数。***

![image20211203113850821](file://C:%5CUsers%5C%E8%94%A1%E6%98%8C%E4%BA%A8%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211203113850821.png?msec=1716629103682)

在延时和LED进行初始化以后，就进入了程序的主体 while(1)，初始化是一件很容易理解的事情，我们并不意外。接下来的代码，清晰可见的是似乎把LED看成了一个变量，通过直接对变量进行赋值就能够改变当前LED0的亮灭状态，然后利用延时函数就可以实现灯的闪烁。

### 二、PWM占空比控制

脉冲宽度调制(PWM)，是英文“Pulse Width Modulation”的缩写，简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。简单一点，就是对脉冲宽度的控制。

要使STM32的通用定时器TIMx产生PWM输出我们还会用到3个寄存器，来控制PWM的。这三个寄存器分别是：捕获/比较模式寄存器（TIMx\_CCMR1/2）、捕获/比较使能寄存器（TIMx\_CCER）、捕获/比较寄存器（TIMx\_CCR1\~4）。

捕获/比较模式寄存器1（TIMx\_CCMR1）作用：在PWM输出模式下，确定PWM的模式、使能相应的预装载寄存器等操作。在输出模式下，该寄存器的值与CNT的值比较，根据比较结果产生相应动作。利用这点，我们通过修改这个寄存器的值，就可以控制PWM的输出脉宽了。本章，我们使用的是TIM3的通道2，所以我们需要修改TIM3\_CCR2以实现脉宽控制DS0的亮度。

配置相关函数：

![image20211203104003864](file://C:%5CUsers%5C%E8%94%A1%E6%98%8C%E4%BA%A8%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211203104003864.png?msec=1716629103693)

输出：

![image20211203104512662](file://C:%5CUsers%5C%E8%94%A1%E6%98%8C%E4%BA%A8%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211203104512662.png?msec=1716629103683)

加载到开发板后可观测到指示灯LED3按配置时长闪烁。

![image20211203104911776](file://C:%5CUsers%5C%E8%94%A1%E6%98%8C%E4%BA%A8%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211203104911776.png?msec=1716629103683)

修改main中此行函数变量可调整闪烁亮度，PWM频率与亮度反比，降低频率使亮度变化小。

### 三、串口收发中断的使用

串口通讯的数据包由发送设备通过自身的TXD接口传输到接收设备的RXD接口，通讯双方的数据包格式要规约一致才能正常收发数据。STM32中串口异步通信需要定义的参数：起始位、数据位（8位或者9位）、奇偶校验位（第9位）、停止位（1,15,2位）、波特率设置。UART串口通信的数据包以帧为单位，常用的帧结构为：1位起始位+8位数据位+1位奇偶校验位（可选）+1位停止位。

状态寄存器适用于检测串口此时所处的状态。它能够检测到的状态有：发送寄存器空位、发送完成位、读数据寄存器非空位、检测到主线空闲位、过载错误为等等。

USART\_DR实际是包含了两个寄存器，一个专门用于发送的TDR，一个专门用于接收的RDR。进行发送数据操作时，往USART\_DR写入数据会自动存储在TDR内；当进行读取数据操作时，向USART\_DR读取数据会自动提取RDR数据。串行通信时一位一位传输的，所以TDR和RDR寄存器都是介于系统总线和移位寄存器间的；发送数据时把TDR内容转移到发送移位寄存器上，接收数据时则是把接收到的每一位顺序保存在接收移位寄存器内进而转移到RDR。

控制寄存器主要是设置USART使能、检验控制使能、校验选择（奇校验偶校验）、PE中断使能、发送缓冲区空中断使能、发送完成中断使能、接收缓冲区非空使能、发送使能、接受使能、字长等等。

接收器和发送器的波特率在USARTDIV的整数和小数寄存器中的值应设置成相同。

Tx / Rx 波特率 ＝ ![img](file:///C:/Users/%E8%94%A1%E6%98%8C%E4%BA%A8/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png?msec=1716629103692) （1）

这里的fCK是给外设的时钟(PCLK1用于USART2、3、4、5，PCLK2用于USART1)

USARTDIV是一个无符号的定点数。这12位的值设置在USART\_BRR寄存器。

注： 在写入USART\_BRR之后，波特率计数器会被波特率寄存器的新值替换。因此，不要在通信进行中改变波特率寄存器的数值,物理结构如下图8。

实验库函数：

1.串口时钟使能。串口是挂载在 APB2 下面的外设，所以使能函数为：

RCC\_APB2PeriphClockCmd(RCC\_APB2Periph\_USART1)；

2.串口复位。当外设出现异常的时候可以通过复位设置，实现该外设的复位，然后重新配置这个外设达到让其重新工作的目的。一般在系统刚开始配置外设的时候，都会先执行复位该外设的操作。 复位的是在函数 USART\_DeInit()中完成：

3.串口参数初始化。 串口初始化是通过 USART\_Init()函数实现的。

数据发送与接收。

STM32的发送与接收是通过数据寄存器 USART\_DR 来实现的，这是一个双寄存器，包含了 TDR 和 RDR。当向该寄存器写数据的时候，串口就会自动发送，当收到数据的时候，也是存在该寄存器内。

初始化：

![image20211203113057782](file://C:%5CUsers%5C%E8%94%A1%E6%98%8C%E4%BA%A8%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211203113057782.png?msec=1716629103693)

运行函数：

![image20211203113132265](file://C:%5CUsers%5C%E8%94%A1%E6%98%8C%E4%BA%A8%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211203113132265.png?msec=1716629103692)

核心控制面板不断闪烁，提示系统正在运行。

### 七、RTC实验

STM32的实时时钟（RTC）是一个独立的定时器。STM32 的 RTC 模块拥有一组连续计数的计数器，在相应软件配置下，可提供时钟日历的功能。修改计数器的值可以重新设置系统当前的时间和日期。

RTC模块和时钟配置系统(RCC\_BDCR 寄存器)是在后备区域，即在系统复位或从待机模式唤醒后 RTC 的设置和时间维持不变。但是在系统复位后，会自动禁止访问后备寄存器和 RTC，以防止对后备区域(BKP)的意外写操作。所以在要设置时间之前， 先要取消备份区域（BKP）写保护。

RTC由两个主要部分组成，第一部分(APB1 接口)用来和 APB1 总线相连。此单元还包含一组 16 位寄存器，可通过 APB1 总线对其进行读写操作。APB1 接口由 APB1 总线时钟驱动，用来与 APB1 总线连接。

另一部分(RTC 核心)由一组可编程计数器组成，分成两个主要模块。第一个模块是 RTC 的预分频模块，它可编程产生 1 秒的 RTC 时间基准 TR\_CLK。RTC 的预分频模块包含了一个 20位的可编程分频器(RTC 预分频器)。如果在 RTC\_CR 寄存器中设置了相应的允许位，则在每个TR\_CLK 周期中 RTC 产生一个中断(秒中断)。第二个模块是一个 32 位的可编程计数器，可被初始化为当前的系统时间，一个 32 位的时钟计数器，按秒钟计算，可以记录 4294967296 秒，约合 136 年左右，作为一般应用，这已经是足够了的。

RTC 最重要的寄存器，RTC 计数器寄存器 RTC\_CNT。该寄存器由 2 个 16位的寄存器组成 RTC\_CNTH 和 RTC\_CNTL，总共 32 位，用来记录秒钟值（一般情况下）。

RTC 闹钟寄存器，该寄存器也是由 2 个 16 为的寄存器组成 RTC\_ALRH 和 RTC\_ALRL。总共也是 32 位，用来标记闹钟产生的时间（以秒为单位），如果 RTC\_CNT 的值与 RTC\_ALR 的值相等，并使能了中断的话，会产生一个闹钟中断。该寄存器的修改也要进入配置模式才能进行。

![image20211203115533929](file://C:%5CUsers%5C%E8%94%A1%E6%98%8C%E4%BA%A8%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211203115533929.png?msec=1716629103683)
